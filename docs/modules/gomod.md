# Модули и пакеты

## Модуль

Директория, в которой я веду разработку некой программы, называется **модулем**,
при условии, что в этой директории была вызвана команда:

```bash
go mod init
```

> При старте нового проекта, нужно выполнить команду go mod init myproject-name, находясь в корне нового модуля (например ~/home_projects/golang).
> Имя модуля часто пишут как путь к репозиторию (если планируется пушить на GitHub), например: go mod init github.com/username/myproject

---

## Пакеты

Каждая вложенная директория, начиная от корня, является **пакетом**,
при условии, что в ней есть `.go`-файлы с `package <имя>` в начале.

- **Имена пакетов не содержат путь** — это просто `package logger`, `package database` и т.д.

Например

```
scry/
└── tools/
    └── logger/
        ├── logger1.go
        └── logger2.go
```

Во всех `.go`-файлах внутри `logger/` нужно указать:

```go
package logger
```

- **Импорты** указываются **по пути от корня модуля**, и включают директории:

```go
import "scry/tools/logger"
```

## Пример структуры модуля `daemon-scry`

```
daemon-scry/                    ← модуль (если есть go.mod)
├── main.go                     ← пакет main
├── Database/                   ← пакет Database
│   ├── database.go
│   └── database2.go
├── Tools/                      ← не является пакетом (нет .go-файлов)
│   ├── Logger/                 ← пакет Logger
│   │   ├── logger1.go
│   │   └── logger2.go
│   └── Metrics/                ← пакет Metrics
│       ├── metrics1.go
│       └── metrics2.go
```

---

## Видимость в предалах одного пакета

- Все `.go`-файлы в одной директории с одинаковым `package <имя>` — это один пакет.
- Все функции, переменные, структуры и т.п. **видны внутри этого пакета**,
  даже если их имена начинаются с **маленькой буквы** (то есть они неэкспортируемые).

### Пример

```go
// файл1.go
package mypkg

func internalFunc() {}       // видна в пределах пакета
func ExportedFunc() {}       // тоже видна

// файл2.go
package mypkg

func another() {
    internalFunc()  // ✅ можно
    ExportedFunc()  // ✅ тоже можно
}
```

---

## Экспортируемость

Если нужно, чтобы функции, переменные, структуры и т.п. были **доступны из других пакетов**
(при условии импорта этого пакета), то они должны именоваться **исключительно с большой буквы**.

## Внешние пакеты (модули) в Go

Термины: пакет, модуль, библиотека — в чём разница?

| Термин         | Что это такое                                            | Пример                         |
| -------------- | -------------------------------------------------------- | ------------------------------ |
| **Пакет**      | Каталог с `.go`-файлами и строкой `package` в начале     | `package logger`               |
| **Модуль**     | Коллекция пакетов, управляемая `go.mod`                  | `github.com/user/project-name` |
| **Библиотека** | Обычное неформальное название внешнего модуля или пакета | `github.com/gin-gonic/gin`     |

> В контексте Go, когда мы говорим "подключить внешний пакет", чаще всего речь идёт о модуле, который содержит один или несколько пакетов.

### Подключение

Если наш проект уже инициализирован, то есть в корне есть файл go.mod, то там же в корне выполняем:

``` bash
go get github.com/gorilla/mux
```
> Тут go get — команда, которая добавляет зависимость в go.mod (если её ещё нет) и скачивает нужную версию модуля в кэш, а github.com/gorilla/mux адрес расположения модуля на github.

Что происходит при go get?

- Go ищет нужный модуль на proxy-сервере (например, proxy.golang.org).

> По умолчанию Go не обращается напрямую к GitHub (или другому VCS-серверу), даже если мы указываем go get github.com/user/repo.
> Сначала он обращается к прокси-серверу. По умолчанию это https://proxy.golang.org
> Прокси проверяет, есть ли нужная версия у него в кэше, если нет — один раз сам скачивает модуль с GitHub (или другого VCS-источника).
> Далее кэширует его у себя и отдает Go-компилятору.
> Если прокси недоступен или отключён — тогда Go обращается напрямую к GitHub.

> Где настраивается поведение?
> Через переменную окружения GOPROXY.

> | Значение `GOPROXY`                     | Что это означает                                                   |
> | -------------------------------------- | ------------------------------------------------------------------ |
> | `https://proxy.golang.org` (по умолч.) | Использует официальный прокси от Google                            |
> | `direct`                               | Обращается **напрямую** к источнику (GitHub и т.д.)                |
> | `off`                                  | **Запрещает любые обращения в интернет**                           |
> | `https://proxy1,https://proxy2,direct` | Порядок попыток: сначала proxy1, потом proxy2, потом прямой доступ |

> Пример: скачать напрямую с GitHub
> ```go
> GOPROXY=direct go get github.com/gorilla/mux@v1.8.0
> ```
> Как правило, менять это поведение не требуется и даже не рекомендуется — это может быть менее безопасно и медленнее.

- Скачивает его в $GOPATH/pkg/mod.

> Тут важно понимать, что go скачивает файлы модуля только один раз и кладёт в глобальный кэш, расположенный по пути $GOPATH/pkg/mod.
> Даже если у нас 5 разных проектов, и во всех мы используем github.com/gorilla/mux — код будет храниться в единственном экземпляре для каждой версии. Если точнее, то в одном экземпляре на версию: если мы используем v1.8.0 и v1.9.0 в разных проектах, то обе версии будут лежать отдельно.
> В каждый проект, внешний модуль не копируется физически.
> Проект просто ссылается на нужную версию в глобальном кэше через систему go.mod.

> Для мониторинга подключенных в проект модулей существует команда go list.

> Например:
>```go
> go list -m all
>```
>Показывает все зависимости текущего проекта (текущего модуля), включая:
> - основной модуль (то есть сам проект)
> - все прямые зависимости (то, что мы сами импортируем)
> - все косвенные зависимости (то, что импортируют наши зависимости)

> Также могут быть полезными:

> - go list -m <moduleName>    Показывает конкретную версию модуля в текущем проекте.

> - go list -m -json <moduleName>    Выдаёт полную информацию в JSON (путь, версия, замены).

> - go list -m -versions <moduleName>    Показывает доступные версии (если есть подключение к proxy).

> - go mod graph    Граф зависимостей, то есть кто кого требует.

> - Вывод в виде дерева: go mod graph | grep yourproject | sed 's/yourproject /├── /'.

> - Или установить go install github.com/loov/goda/cmd/modgraphviz@latest и вызвать go mod graph | modgraphviz | dot -Tpng -o graph.png. Это сгенерирует PNG-файл с красивой схемой зависимостей.

> - go mod why <module>    Почему этот модуль вообще попал в зависимость.


- Добавляет нужную версию в файл go.mod.

> Если необходимо, то можно указать версию при установке
> ```bash
> go get github.com/gorilla/mux@v1.8.0
> ```
> Если не указана — будет скачана последняя стабильная версия.

- Создаёт запись в go.sum (контрольные суммы для проверки целостности).

---
> **Важно!**

> Порядок подключения модуля может быть и другой. Например:
> ```go
> //Импортируем пакет в проект
> import "github.com/gorilla/mux"
> ```
> Go сам поймёт, что модуль нужен, и при следующей компиляции (go build, go run) он его скачает и добавит описание зависимостей в go.mod.
---

### go mod tidy

Команда go mod tidy — это инструмент очистки и синхронизации зависимостей в проекте на Go. Она анализирует код, go.mod и go.sum и приводит их в порядок.

Например:

1. Удаляет из go.mod и go.sum те модули, которые больше не используются в коде (ни напрямую, ни через зависимости).

2. Добавляет недостающие зависимости. То есть если мы добавили в код import "github.com/some/module" но при этом не выполнили go build, go run или go get, то go mod tidy подтянет зависимость на основе import "github.com/some/module" в go.mod и обновит go.sum.

3. Упорядочивает go.mod. То есть: сортирует require по алфавиту, группирует indirect зависимости, убирает лишние пробелы и дубли.

4. Очищает go.sum. То есть удаляет контрольные суммы: для зависимостей, которые больше не нужны и для версий, которые больше не используются.

Вывод: рекомендуется вызывать go mod tidy перед каждым коммитом — это гарантирует чистоту зависимостей, минимальный go.mod и актуальный go.sum.

## Продвинутые возможности работы с модулями в Go

### Локальная замена модулей: replace

Иногда бывает нужно использовать локальную версию внешнего модуля. Для этого используется директива replace в go.mod:
```go
replace github.com/user/lib => ../local-lib
```
Теперь при импорте github.com/user/lib, Go будет использовать локальную папку ../local-lib вместо скачанной из интернета.
Это удобно когда мы одновременно работаем над:
- основным приложением (например, myapp)
- и отдельной библиотекой или модулем (например logger)

Пример ситуации

У нас есть:

- ~/projects/myapp — основное приложение
- ~/projects/logger — библиотека логирования

Мы пишем и тестируем обновлённую версию logger, и хотим, чтобы myapp прямо сейчас использовал эту свежую версию, не дожидаясь коммита и пуша в GitHub.

### Исключение версий модулей: exclude

Если по каким-то причинам мы хотим запретить использовать конкретную версию внешнего модуля, можно использовать директиву exclude:
```go
exclude github.com/example/oldlib v1.2.3
```
Go проигнорирует указанную версию даже если кто-то из зависимостей её требует. Используется крайне редко.

> **Пример использования**

> Допустим, мы используем библиотеку github.com/example/dbdriver, и она в версии v1.2.3 вызывает сбой.
> Но мы знаем, что стабильная — v1.2.2.

> Мы можешь прописать:
> ```go
> exclude github.com/example/dbdriver v1.2.3
> require github.com/example/dbdriver v1.2.2
> ```

> Теперь даже если какая-то другая зависимость (транзитивно) попросит v1.2.3, Go откажется её использовать — и будет искать подходящую альтернативу.

Что значит indirect в go.mod?
Этим словом помечены модули не используемые напрямую нашим проектом, но они используются каким-то из модулей которые мы используем явно. То есть это зависимости подключенных нами модулей.

Пример

Мы подключаю модуль github.com/VitaliySuhomlinov/dhp, а в этом модуле подключается github.com/davecgh/go-spew, то именно github.com/davecgh/go-spew будет помечен как indirect.
```go
require github.com/vysmv/dhp v0.0.0-20250619114632-45129e55507a
require github.com/davecgh/go-spew v1.1.1 // indirect
```

### Работа без интернета: go mod vendor
Если нам нужно собрать проект в среде, где нет доступа к proxy-серверам или GitHub, можно заранее сформировать папку vendor/ с копиями всех зависимостей:
```bash
go mod vendor
```

Go будет использовать vendor/, если мы явно укажем:
```bash
go build -mod=vendor
```

Также vendor/ может быть полезен при проверках лицензий и для некоторых CI/CD-сценариев.

### Предзагрузка зависимостей: go mod download
Если нам нужно просто скачать все зависимости, но пока не нужно собирать проект — используем:
```bash
go mod download
```
Эта команда просто скачает все зависимости указанные в go.mod, в кэш $GOPATH/pkg/mod и все.

### Несколько модулей в одном проекте: go.work
Механизм go.work появился в Go 1.18 и предназначен для разработки нескольких модулей одновременно, когда эти модули живут рядом на диске и зависимы друг от друга, но не опубликованы в общий доступ (например, в GitHub).

Вместо того чтобы писать replace в каждом go.mod, можно создать рабочее пространство, которое объединит все модули.

Создание:
```bash
go work init ./backend ./common ./cli-tool
```

Появится файл go.work, где будут прописаны пути к локальным модулям. Теперь они видят друг друга напрямую без replace.

Это удобно:

- для монорепозиториев
- для локальной разработки нескольких зависимых модулей

