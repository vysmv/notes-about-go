# Переменные и базовые типы

## Создание переменных

В Go есть два основных способа объявления переменных:

- var — более формальный способ, подходит для использования в любом месте (в том числе вне функции).
- краткий способ, можно использовать только внутри функции и только при одновременном объявлении хотя бы одной новой переменной.

**Явное объявление с типом и значением:**

```go
var x int = 10
```

**Автоматическое определение типа на основе значения:**

```go
var x = 10 // x: int
```

**Создание нескольких переменных сразу:**

```go
var x, y int = 10, 20
var a, b = 1, "text"
var (
	m int
	n = 42
	o int = 7
	p, q = "hi", 3.14
)
```

## Нулевое значение (zero value)

В Go переменные получают значение по умолчанию сразу после объявления:

```go
var i int     // 0
var f float64 // 0.0
var s string  // ""
var b bool    // false
```

> Идиома:
>
> не обязательно инициализировать переменные "пустыми значениями" — Go уже делает это.

## Литералы

Если в правой части выражения (right value) мы просто указываем число, строку, символ или логическое значение — это литерал.

Целочисленные:
```go
a := 42         // десятичный
b := 0b1010     // двоичный
c := 0o755      // восьмеричный
d := 0xFF       // шестнадцатеричный
e := 1_000_000  // читаемо: 1 миллион
```

С плавающей точкой:
```go
pi := 3.14
avogadro := 6.022e23
hexFloat := 0x1p-2 // = 0.25
```

Руны (rune — тип alias к int32):
```go
var r rune = 'a'       // символ
var r2 rune = '\u0061' // Unicode
var r3 rune = '\n'     // спецсимвол
```

Строки:
```go
s1 := "Hello\nWorld" // интерпретируемая строка
s := `Hello
"World"
This\tis not escaped
\nope`
fmt.Println(s) // "сырая" строка с ``
```

> Сырые строки — это аналог heredoc в PHP.
> Никакие экранирования (\n, \t, \") внутри него не работают.
> Можно писать многострочные строки без +, \ или fmt.Sprintf.
> Это удобно, когда:
>
> - мы хотим вставить текст как есть (например, SQL-запрос, шаблон, HTML);
> - нужно сохранить форматирование.

### Литералы — нетипизированные значения

Пояснение:

- Литерал не имеет типа сам по себе, пока его не используют в контексте с конкретным типом.
- Это даёт гибкость: мы можем использовать один и тот же литерал в выражениях с разными типами.

```go
var x int = 42     // ✅ литерал "42" автоматически «подстраивается» под тип int
var y float64 = 42 // ✅ тот же самый литерал "42", но теперь как float64
```

Пример с const:
```go
const n = 10
var a int = n      // OK
var b float64 = n  // OK
```

> Важно!
>
> Константы могут быть типизированные и нетипизированные.
> Если мы создаём константу так:
> const n = 10, то это нетипизированный литерал.
> А вот если так:
> const x int = 10, то это уже явно типизированная константа.

## Логические значения (bool)

```go
var flag bool       // false — нулевое значение
var isAwesome = true // явное присваивание
```

В отличие от, например, C, Go не позволяет использовать числа как логические значения:

```go
if 1 { } // ❌ ошибка: 1 не bool
```

> Идиома
>
> В Go всё должно быть явным и типобезопасным, даже логика.

## Числовые типы

Go предлагает 12 числовых типов:

- int8, int16, int32, int64
- uint8, uint16, uint32, uint64
- int, uint
- byte (alias для uint8)
- rune (alias для int32)
- uintptr — спецтип, адрес в памяти (о нём позже)

Как различаются?

| Тип      | Размер                          | Знак     | Пример использования                   |
|----------|----------------------------------|----------|----------------------------------------|
| `int8`   | 1 байт                           | ±        | компактное хранение чисел              |
| `int64`  | 8 байт                           | ±        | работа с большими числами              |
| `uint32` | 4 байта                          | только + | бинарные протоколы                     |
| `byte`   | 1 байт                           | только + | удобно при работе с `[]byte`           |
| `int`    | зависит от архитектуры (32/64)   | ±        | идиоматичный выбор по умолчанию        |

> Важно!
>
> Даже если используется 64-битная платформа, то мы НЕ сможем сделать так:
> ```go
> var age1 int64 = 100
> var age2 int = age1
> ```
> Несмотря на то, что на 64-битной платформе `int` фактически равен `int64` по размеру, для компилятора это разные типы. Go требует явного приведения типов:
> ```go
> var age int64 = 100
> var age2 int = int(age) // явное преобразование
> ```

> Идиома:
>
> если нет явного требования использовать какой-то конкретный тип, то лучше использовать `int`.

## Специальные псевдонимы

- `byte = uint8` — удобно, когда мы явно работаем с байтами (например, `[]byte`)
- `rune = int32` — используется для Unicode-символов
- `uintptr` — спецтип, обычно в `unsafe`-коде (например, когда мы работаем с указателями на память)

`byte` и `rune` — это настоящие псевдонимы, не просто равенство по размеру.
В языке Go:

- `type byte = uint8`
- `type rune = int32`

То есть их можно присваивать друг другу:

```go
var b byte = 255
var u uint8 = b    // OK
var x byte = u     // OK
var r rune = 'а'
var i int32 = r    // OK
var r2 rune = i    // OK
```

## Тип переменной

Для отображения типа переменной необходимо использовать функцию `Printf` из пакета `fmt`.

```go
package main

import "fmt"

type User struct {
	Name string
}

func main() {
	name := "Americano"
	proce := 2.99
	ready := true
	count := 5
	user := User{Name: "Ivan"}

	fmt.Printf("%T\n%T\n%T\n%T\n%T\n", name, proce, ready, count, user)
}
```

Вывод:
```bash
string
float64
bool
int
main.User
```

Для более продвинутой работы можно использовать `TypeOf` из пакета [`reflect`](https://pkg.go.dev/reflect).

**Что даёт `reflect.TypeOf(...)`, чего нет у `fmt.Printf("%T")`**

| Возможность                               | `fmt.Printf("%T")` | `reflect.TypeOf(...)` |
|-------------------------------------------|--------------------|------------------------|
| Вывод имени типа                          | ✅                 | ✅                     |
| Получение `reflect.Type` объекта          | ❌                 | ✅                     |
| Анализ структуры (struct fields, methods) | ❌                 | ✅                     |
| Получение `Kind()` (slice, map, int, etc) | ❌                 | ✅                     |
| Анализ типов в runtime (generic/logging)  | ❌                 | ✅                     |

Вывод:

- `fmt.Printf("%T")` — удобно напечатать тип.
- `reflect.TypeOf(...)` — нужно, когда мы хотим исследовать или работать с типом программно.

## Строгая типизация

Go — язык со строгой типизацией, а это значит, что проводить операции между двумя переменными с разными типами невозможно. Go не делает неявное приведение типа, как в PHP/Python. Например, если нужно сложить две переменные разных типов (int/float64), то одну из них нужно привести к типу второй.

### Преобразование между числовыми типами

Без приведения типов будет ошибка:
```go
price := 10.5
count := 14
total := price * count // invalid operation: price * count (mismatched types float64 and int)compilerMismatchedTypes
```

Необходимо провести преобразование:
```go
price := 10.5
count := 14
total := price * float64(count)
fmt.Println(total) // 149.79999999999998
```

Мы можем провести и обратное преобразование, то есть привести float64 к int. Но тогда будет побочный эффект, который нужно учитывать — это усечение float64 в меньшую сторону.

```go
price := 10.7
count := 14
total := int(price) * count // price усекся до 10
fmt.Println(total) // 147
```

### Преобразование числа в строку

Для строк всё интереснее — здесь не работает просто `string(i)`, как может показаться.

**int/float → string**
Для int и float64 преобразование требует пакета [`strconv`](https://pkg.go.dev/strconv):

```go
import "strconv"

s := strconv.Itoa(123)                      // "123" (int → string)
s2 := strconv.FormatFloat(3.14, 'f', 2, 64) // "3.14" (float64 → string)
```

Аргументы `strconv.FormatFloat`:

- `'f'` — формат (fixed-point),
- `2` — количество знаков после запятой,
- `64` — битность float'а (32 или 64).

Прямое приведение `string(int)` даст символ с соответствующим Unicode-кодом:

```go
var i int = 65
fmt.Println(string(i)) // "A", а не "65"
```

### Преобразование строки в число

```go
n, err := strconv.Atoi("123")            // string → int
f, err := strconv.ParseFloat("3.14", 64) // string → float64
```

❗ Здесь всегда есть `error`, и его нужно проверять — строка может быть некорректной.

### Преобразование []byte ↔ string

```go
s := "hello"
b := []byte(s)  // string → []byte
s2 := string(b) // []byte → string
```

Безопасно и быстро: `[]byte` и `string` совместимы по внутреннему представлению.

### Преобразование массива, среза, мапы и структуры

| Тип       | int / float64 | string                     |
|-----------|----------------|----------------------------|
| `[]byte`  | ❌              | ✅ (строка из байтов)       |
| `[N]byte` | ❌              | ✅ через `[:]`              |
| `[]int`   | ❌              | ❌ (нужно `fmt` или `json`) |
| `map`     | ❌              | ❌ (только через `json`)    |
| `struct`  | ❌              | ❌ (через `fmt`/`json`)     |


## Константы
В Go ключевое слово const позволяет объявлять константы, которые:
- вычисляются во время компиляции,
- не могут быть изменены в рантайме,
- используются для представления литералов с именами.

**Пример объявления**

```go
const x int64 = 10
const (
	idKey = "id"
	nameKey = "name"
)
const z = 20 * 10
```

- x — типизированная константа (int64)
- idKey, nameKey — строковые константы
- z — результат компилируемого выражения 20 * 10, тоже константа

### Что можно присвоить const?

Только значения, известные на этапе компиляции:

- числовые литералы (42, 3.14, 0xFF)
- строки ("hello")
- руны ('a')
- true, false
- встроенные функции, если они могут быть вычислены компилятором: len, cap, real, imag, complex

> ⚠️ В отличие от C++ или Rust, нельзя сделать const-ом массив, срез, карту или структуру — даже если они не изменяются. Нет и const field в структурах.

### Типизированные и нетипизированные константы

**Нетипизированная константа**
```go
const x = 10
```

- Тип по умолчанию будет выводиться из контекста.
- Поведение аналогично литералу.
- Гибкость: x можно использовать как int, float64, byte — смотря куда присваиваем.

```go
var a int = x  	// ok
var b float64 = x  // ok
var c byte = x 	// ok
```

**Типизированная константа**
```go
const typedX int = 10
```

- Жёстко привязана к типу int
- Присвоить как float64 или byte — ❌ ошибка компиляции:

```go
var f float64 = typedX // ❌ cannot use typedX (type int) as type float64
```
**Когда какую использовать?**

| Случай                          | Какую выбрать      |
|---------------------------------|---------------------|
| Универсальные числовые значения | ❗ Нетипизированную |
| Требуется строгая типизация     | ✅ Типизированную   |
| Константы для enum + iota       | Типизированную      |

> Идиома:
>
> Const как "имя для литерала", а не инструмент для контроля мутабельности
> Это важное отличие от других языков, где const часто означает неизменяемый объект в памяти.
> В Go это — просто символическое имя для известного значения.