# Функции в Go

Функция — это именованный фрагмент кода, который инкапсулирует определённую логику и может быть многократно вызван из разных частей программы, что способствует повторному использованию, читаемости и модульности кода.


При описании сигнатуры функции, мы можем указывать набор параметров, а вот при вызове функции, мы передаем ей аргументы.
```go
package main

import (
    "fmt"
)

func sum(x, y int ) int {
    // описывая сигнатуру указываем параметры
    return x + y
}

func main() {
    res := sum(2, 2) // передаем аргументы
    fmt.Println(res)
}
```

## Возвращаемые значения

**Стандартный способ возврата значения**

```go
func sum(value float64) int {
    return int(value + 2)
}
```

**Множественные возвращаемые значения**

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("деление на ноль")
    }
    return a / b, nil
}
```

**Именованные возвращаемые значения**

```go
func calculate(a, b int) (sum int, product int) {
    sum = a + b
    product = a * b
    return // не указываем переменные — возвращаются по именам
}
```

Но тут может возникнуть вопрос, зачем вообще нужны именованные возвращаемые значения, если в большинстве случаев мы потом принимаем их в переменные с другими именами?

Ответ:

1. Улучшение читаемости внутри функции

```go
func rectangleProps(width, height float64) (area, perimeter float64) {
    area = width * height
    perimeter = 2 * (width + height)
    return // короткий return, всё уже присвоено
}
```

**Не нужно явно указывать return area, perimeter — они уже заполнены.**

2. Использование в defer или логике с recover()

Например, если мы хотим залогировать, что именно вернёт функция:

```go
func process() (result string) {
    defer func() {
        fmt.Println("Функция возвращает:", result)
    }()
    result = "Готово"
    return
}
```

result виден в defer, потому что он — локальная переменная в области видимости функции process. А defer-функции — замыкания, они всегда видят локальные переменные той функции, в которой они определены.

3. Полезно в длинных функциях или когда return не один

```go
func fetchData() (data string, err error) {
    if problem {
        err = errors.New("ошибка") // data остаётся пустой строкой
        return                    // return "data", "err" => "", ошибка
    }

    data = "успешный результат" // err остаётся nil
    return                      // return "data", "err" => "успешный результат", nil
}
```

На первый взгляд тут противоречие. Указано - функция возвращает два значения но логика выполнения функции говорит о том,  что вернется ил то или то.

Вся суть в том, что при обьявлении в сигнатуре двух именованых переменных, в качестве возвращаемых, они становятся обычными локальными переменными с дефолтными значениями.

В итоге если мы зайдем в if, то определим значение для err, а data останется пустой строкой.

return же вернет их без прямого указания, операясь на сигнатуру.

4. Возврат интерфейсов

Можно вернуть значение, реализующее интерфейс:
```go
type Shape interface {
    Area() float64
}

func getShape() Shape {
    return Circle{Radius: 10}
}
```

Тут мы говорим, что функция должна вернуть значение которое реализует интерфейс Shape. Этот пример означает что мы возвращаем экземпляр структуры Circle для которой (где то за кулиссами реализован метод Area).

Например так:
```go
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}
```

## Игнорирование возвращаемых значений

```go
_, err := divide(10, 0)
if err != nil {
    fmt.Println("Ошибка:", err)
}
```

## Анонимные функции (Функциональные литералы)

Анонимная функция и функциональный литерал — это синонимы в языке Go.

> Технически:
>
> Function literal — это синтаксическая конструкция func(...) { ... }, которая создаёт анонимную функцию, то есть значение типа func.

### Что представляет собой функциональный литерал (он же анонимная функция)?

Это выражение, например:
```go
func(x int) int {
    return x * 2
}
```

— создаёт значение типа func(int) int.

Эта конструкция:

- Не имеет имени
- Может быть:
  - Немедленно вызвана

```go
var result = func(x int, y int) int {
   return x + y
}(3, 4)

fmt.Println(result) // 7
```


  - Присвоена переменной
```go
var result = func(x int, y int) int {
    return x + y
}
```
  - Передана как аргумент
 ```go
 func apply(x int, f func(int) int) int {
     return f(x)
 }

 func main() {
     result := apply(5, func(y int) int {
     return y * y
})

fmt.Println(result) // 25
```
  - Возвращена из другой функции
```go
package main

import "fmt"

// makeMultiplier возвращает анонимную функцию, которая умножает на factor
func makeMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    times2 := makeMultiplier(2)
    times3 := makeMultiplier(3)

    fmt.Println(times2(5)) // 10
    fmt.Println(times3(5)) // 15
}
```

> Что происходит:
>
> - makeMultiplier — обычная функция, принимающая factor int
> - Она возвращает анонимную функцию типа func(int) int
> - Анонимная функция замыкает переменную factor
> - В main() мы вызываем makeMultiplier(...) и сохраняем результат в переменные times2, times3
> - Эти переменные — функции, которые можно вызывать

### Где можно объявить анонимную функцию?

Везде где допустимо использование выражений.

## Замыкания (closures)

Замыкание — это функция, которая «запоминает» переменные из своей внешней области видимости, даже после выхода из неё.

В Go замыкание реализуется через анонимные функции, которые имеют доступ к внешним переменным, даже если вызываются позже.

### Как выглядит замыкание в Go?

```go
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {

    var foo = makeCounter()
    fmt.Println(foo()) // 1
    fmt.Println(foo()) // 2
}
```

 Что здесь происходит:

- makeCounter возвращает анонимную функцию
- Эта функция использует переменную count, определённую вне себя
- count — не локальная переменная анонимной функции, а переменная, замкнутая из внешней функции

**Переменная count живёт, пока живёт функция counter, хотя makeCounter() уже давно завершилась.**

### Особенности работы замыканий в Go в сравнении с PHP

По умолчанию в Go замыкается именно ссылка на переменную.

Например:

```go
func main() {

    x := 42
    foo := func() {
        fmt.Println(x) // x «замкнут»
    }

    x = 24

    foo() // 24
}
```

В PHP же п умолчанию замыкается значение ,то есть создается копия.

Например:
```go
$x = 42;

$foo = function() use($x) {
    echo $x;
};

$x = 24;

$foo(); // 42
```

Но мы можем поменять это поведение в обоих случаях.

Например PHP по ссылке:
```go
$x = 42;

$foo = function() use(&$x) {
    echo $x;
};

$x = 24;

$foo(); // 24
```

или Go по значению:
```go
x := 42
y := x // вручную копируем значение, то есть создаем промежуточное значение

foo := func() {
    fmt.Println(y) // теперь независимая копия
}

x = 24

foo() // 👉 42
```

Но важно понимать, что мы просто теперь передаем ссылку на y.

## Defer

Первым делом ,для понимания темы defer нам необходимо освоить, что такое структура данных stack.
Стек это когда новые данные кладутся сверху и забираются сверху. То есть первым пришел, последним ушел.

defer - работает с любыми вызываемыми функциями, будь то:

- обычные именованные функции,
- методы,
- анонимные функции (функциональные литералы),
- функции, возвращаемые из других функций,
- и даже встроенные (recover, close и т.п.).

1. Обычная именованная функция
```go
func cleanup() {
    fmt.Println("cleanup called")
}

func main() {
    defer cleanup() // ✅ работает
}
```

2. Анонимная функция
```go
func main() {
    defer func() {
        fmt.Println("deferred anon func")
    }()
}
```

3. Метод
```go
type File struct{}

func (f *File) Close() {
    fmt.Println("File closed")
}

func main() {
    f := &File{}
    defer f.Close() // ✅ работает
}
```

4. Вызов возвращённой функции
```go
func getFunc() func() {
    return func() {
        fmt.Println("from returned function")
    }
}

func main() {
    defer getFunc()() // ✅ тоже работает
}
```

5. Встроенная функция
```go
func main() {
    defer fmt.Println("end") // ✅ можно даже defer'ить вызов fmt.Println
}
```

В языке Go оператор defer используется для отложенного вызова функции. Вызов, помеченный defer, будет выполнен в момент выхода из текущей функции, независимо от того, как именно произошёл выход (нормально или через panic).

Например:
```go
func main() {
    fmt.Println("start")
    defer fmt.Println("deferred")
    fmt.Println("end")
}
```

Вывод:
```bash
start
end
deferred
```

### Порядок выполнения

Если несколько defer, они выполняются в обратном порядке (LIFO\stack) — последним объявлен → первым выполнен:
```go
func main() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
```

Вывод:
```go
3
2
1
```

То есть функции вызванные через defer f() складываются в стек.

### Когда вычисляются аргументы?

Аргументы функции, указанной в defer, вычисляются немедленно, а сама функция — позже.
```go
func say(msg string) {
    fmt.Println(msg)
}

func main() {
    msg := "hello"
    defer say(msg)
    msg = "world"
}
```

Вывод:
```bash
hello
```

**Потому что msg вычислен на момент defer, а не на момент вызова.**

### Пример с побочным эффектом

```go
func main() {
    defer fmt.Println("result:", compute())
}

func compute() int {
    fmt.Println("compute() called")
    return 42
}
```

Вывод:
```bash
compute() called
result: 42
```

**compute() вызывается сразу, fmt.Println(...) — позже.**

### Частое применение

Закрытие ресурсов:

```go
f, _ := os.Open("file.txt")
defer f.Close()
```