# Массивы
Массив в Go — это значение фиксированного размера, представляющее собой непрерывную область памяти, в которой хранятся элементы одного и того же типа. Все элементы располагаются последовательно и доступны по индексу.
Память для массива может быть выделена как в стеке, так и в куче — это зависит от результата escape-анализа компилятора. Компилятор Go выполняет escape-анализ, чтобы определить, «уходит» ли переменная за пределы функции. Если нет — массив размещается в стеке, иначе — в куче.

Пример массива, который размещается в стеке:
```go
func f() {
    var a [100]int
}
```

Здесь `a` — локальная переменная с фиксированным размером, не покидающая пределы функции — компилятор обычно оставляет её в стеке.

Если массив большой или его адрес возвращается наружу, он перемещается в кучу:
```go
func makeBigArray() *[1000000]int {
    var a [1000000]int
    return &a // a «утекает» из функции
}
```

Также размещение в куче происходит при использовании new():
```go
a := new([5]int)
```

Здесь `a` — указатель на массив `[5]int`, который будет размещён в куче, поскольку `new([T])` возвращает указатель.
Слайсы, создаваемые через `make([]int, N)`, также используют массив в качестве внутреннего буфера. Этот массив размещается в куче, если это требуется для корректной работы с памятью:
```go
s := make([]int, 100)
```

Наконец, массив в Go — это значимый тип. При передаче массива функции создаётся копия. Чтобы изменить оригинал, нужно передавать указатель:
```go
func modify(a [3]int)   {} // копия
func modifyPtr(a *[3]int) {} // ссылка
```

## Синтаксис объявления массива
```go
var x [3]int
```

Здесь объявляется переменная `x` типа `[3]int` — массив из трёх элементов типа int.
Все элементы инициализируются нулевым значением (0 для int).

> Важно!
>
> Размер — часть типа. Тип массива включает в себя как тип элементов, так и точную длину.
> Это означает:
> ```go
> [3]int ≠ [4]int
> ```
> Даже если оба массива содержат элементы типа int, они считаются разными типами.
> Такое поведение отличает Go от большинства других языков, где размер массива — метаинформация, а не часть типа.

## Инициализация массива
```go
var arr1 = [3]int{10, 20, 30}

//или

arr2 := [3]int{10, 20, 30}
```
- Объявление и инициализация одновременно.
- Явно указаны значения для всех позиций.

## Разреженный литерал (инициализация по индексам)
```go
var x = [12]int{1, 5: 4, 6, 10: 100, 11: 15}
```

- Значение 1 присваивается x[0]
- x[5] = 4,
- x[6] = 6
- x[10] = 100,
- x[11] = 15
- Остальные элементы получают нулевые значения (0 для int)

Итоговый массив:
```go
[1 0 0 0 0 4 6 0 0 0 100 15]
```
Такой способ инициализации удобен, если нужны значения только в отдельных позициях.

## Автоматическое определение длины
```go
var x = [...]int{10, 20, 30}
```

- [...] говорит компилятору самому вывести длину массива по числу элементов — здесь 3.
- Тип `x` в этом случае будет `[3]int`.

> Важно!
>
> Даже с `[...]`, тип массива остаётся фиксированным — `[3]int`, а не "массив произвольной длины".

## Закрепление

| Объявление                                     | Тип переменной | Кол-во элементов | Комментарий             |
| ---------------------------------------------- | -------------- | ---------------- | ----------------------- |
| `var x [3]int`                                 | `[3]int`       | 3                | Все элементы = 0        |
| `var x = [3]int{10, 20, 30}`                   | `[3]int`       | 3                | Полная инициализация    |
| `var x = [12]int{1, 5: 4, 6, 10: 100, 11: 15}` | `[12]int`      | 12               | Разреженный             |
| `var x = [...]int{10, 20, 30}`                 | `[3]int`       | 3                | Длина по числу значений |

## Обращение к элементам массива

Для обращения к элементу используется его индекс:

```go
arr := [3]int{1, 23, 34}
fmt.Println(arr[1]) // 23
```

Элементы массива нумеруются с нуля. То есть чтобы получить первый элемент, обращение должно быть таким:
```go
arr := [3]int{1, 23, 34}
fmt.Println(arr[0]) // 1
```
Обусловлено это тем, что индекс отражает смещение относительно начала области памяти. Когда мы пишем arr[0], это означает: "взять значение из ячейки, находящейся на нулевом смещении от начала массива". Это поведение унаследовано от языков вроде C, где массив — это указатель на первый элемент, а обращение по индексу фактически реализуется как:
```c
*(arr + i)
```
То есть arr[0] — это *(arr + 0), первый элемент, arr[1] — второй, и так далее.

> Важно!
>
> Под капотом Go работает на принципах адресной арифметики.
> Но не даёт ей оперировать программисту напрямую.

> Важно!
>
> При обращении к индексу, выходящему за пределы массива, будет ошибка выполнения (panic: index out of range).
> Go всегда проверяет границы массива во время исполнения.

## Сравнение массивов
```go
x := [...]int{1, 2, 3}
y := [3]int{1, 2, 3}
fmt.Println(x == y) // true
```

Допустимо, так как типы совместимы и значения сравниваются поэлементно.

## Почему массивы редко используются напрямую?
- Их размер — часть типа. [3]int ≠ [4]int. Нельзя создать функцию, принимающую массив произвольной длины без конкретного размера.
- Они не гибкие: нельзя динамически менять размер или добавлять элементы.

**В Go их основное назначение — быть основой для срезов (`slices`).**

## Практика

Допустим, у нас есть массив структур User.
Нам нужно прокрутить его в цикле и прибавить единицу к полю Rating
у каждого пользователя, если Premium установлен в true.

Важно: при использовании цикла `for i, user := range users`,
в переменную `user` попадает **копия** элемента. Поэтому любые изменения
будут применяться только к копии — оригинальный массив не изменится.

Это касается range-циклов по массивам, срезам и map.
Чтобы изменить оригинал, нужно работать через индекс или указатель.
```go
package main

import (
    "fmt"
)

type User struct {
    Name string
    Age int
    Email string
    Rating float64
    Premium bool
}

func main() {
    var users = [3]User{
        {
            Name: "Ivan",
            Age: 32,
            Email: "ivan@gmail.com",
            Rating: 1.2,
            Premium: true,
        },
        {
            Name: "Vitaliy",
            Age: 38,
            Email: "vitaliy@gmail.com",
            Rating: 1.7,
            Premium: true,
        },
        {
            Name: "Irina",
            Age: 33,
            Email: "irina@gmail.com",
            Rating: 1.5,
            Premium: false,
        },
    }

    for _, user := range users {
        if user.Premium {
            user.Rating += 1.0 // // ← изменяется копия, оригинал останется прежним
        }
    }

    fmt.Println(users) // [{Ivan 32 ivan@gmail.com 1.2 true} {Vitaliy 38 vitaliy@gmail.com 1.7 true} {Irina 33 irina@gmail.com 1.5 false}]

    //как вариант можно использовать индекс
    for i, user := range users {
        if user.Premium {
            users[i].Rating += 1.0 // ← изменяется оригинал
        }
    }
    fmt.Println(users) // [{Ivan 32 ivan@gmail.com 2.2 true} {Vitaliy 38 vitaliy@gmail.com 2.7 true} {Irina 33 irina@gmail.com 1.5 false}]

    //Или классический цикл
    for i := 0; i < len(users); i++ {
        if users[i].Premium {
            users[i].Rating += 1.0 // ← изменяется оригинал
        }
    }
    fmt.Println(users) // [{Ivan 32 ivan@gmail.com 3.2 true} {Vitaliy 38 vitaliy@gmail.com 3.7 true} {Irina 33 irina@gmail.com 1.5 false}]
}
```
