# Слайсы

## Внутреннее устройство среза в Go

Под капотом слайс это обычная структура из трех полей
```go
type slice struct {
    Data *T
    Len int
    Cap int
}
```

- Data *T - Указатель на первый элемент массива.
- len int - Текущая длина. То есть реальное кол-во элементов.
- cap int - Ёмкость — это количество элементов, которое можно разместить в срезе до перераспределения памяти.

### Как это работает

Допустим:

```go
arr := [5]int{10, 20, 30, 40, 50}
s := arr[1:4] // элементы 20, 30, 40
```

Тогда `s` будет:

- Data → указатель на arr[1]
- Len → 3 (индексы 1, 2, 3)
- Cap → 4 (от arr[1] до конца arr)

> Важно!
>
> Срез не хранит данные сам по себе, он "ссылается" на массив.
> Несколько срезов могут "ссылаться" на одну и ту же область памяти.

**Визуализация**

```
arr:     [10] [20] [30] [40] [50]
index:    0    1    2    3    4

s := arr[1:4] // [20 30 40]
Data → → →
         ↓
       (arr[1])  20
Len: 3 (элементы с индексом 1,2,3)
Cap: 4 (вся память от arr[1] до arr[4])
```

### Работа с разделяемой памятью

```go
arr := [5]int{10, 20, 30, 40, 50}
s1 := arr[1:4] // [20, 30, 40]
s2 := arr[2:5] // [30, 40, 50]

s1[1] = 999
fmt.Println(arr) // [10 20 999 40 50]
fmt.Println(s2)  // [999 40 50]
```

**Изменение через s1 повлияло на s2, потому что они ссылаются на один и тот же массив.**

### Cap (Capacity)

Срез может быть расширен append()-ом до своей ёмкости без нового выделения памяти.
```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:3]     // [2 3], len = 2, cap = 4
s = append(s, 99) // внутри всё ещё тот же массив!
```

Но:

```go
s = append(s, 88, 77) // превышает cap — будет создан новый массив
```

**После превышения cap, append создаёт новый массив, а старый остаётся "позади".**
Старый массив удаляется Go GC если:
- На него больше никто не ссылается (нет ни одного среза, указателя или другой переменной, ссылающейся на этот массив)
- Он не удерживается замыканием или глобальной переменной

### Отражение (unsafe/reflect)
Если хочется увидеть slice header напрямую (в отладке):

```go
import (
	"fmt"
	"reflect"
	"unsafe"
)

s := []int{1, 2, 3}
h := (*reflect.SliceHeader)(unsafe.Pointer(&s))
fmt.Println(h.Data, h.Len, h.Cap)
```

> **⚠️ Только для чтения. Не рекомендуется использовать в продакшене.**

## Создание срезов в Go

### Через литералы (slice literals)
```go
s := []int{10, 20, 30}
fmt.Println(s)        // [10 20 30]
fmt.Println(len(s))   // 3
fmt.Println(cap(s))   // 3
```

### Из массива (slice expressions)

```go
a := [5]int{10, 20, 30, 40, 50}
s := a[1:4] // срез со 2-го по 4-й (не включая 4-й индекс)
fmt.Println(s)        // [20 30 40]
fmt.Println(len(s))   // 3
fmt.Println(cap(s))   // 4 (от a[1] до конца массива)
s2 := s[:cap(s)] // [20 30 40 50]
fmt.Println(s2) // [20 30 40 50]
```

Здесь:

- `s` — это срез, который "смотрит" на ту же память, что и `a`.
- `len(s)` — количество элементов в диапазоне.
- `cap(s)` — всегда отсчитывается от начала среза до конца массива, на который он ссылается.

> ---
> Детальный разбор
>
> `Срез s := a[1:4]`
>
> Это срез, в котором:
>
> - ptr указывает на a[1] (то есть 20)
> - len = 4 - 1 = 3 → [20 30 40]
> - cap = len(a) - 1 = 5 - 1 = 4
> - То есть cap(s) — это количество элементов от `a[1]` до конца массива `a`, а не только те, которые входят в `s`.
>
> `Новый срез s2 := s[:cap(s)]`
>
> Здесь создаётся новый срез, относительно старого среза `s`, а не массива `a`. Мы говорим: "создай срез из `s`, от начала и до 4 элемента но не включая его".
> Go идёт по указателю ptr в срезе `s`, а s[0] → a[1] и берёт 4 элемента подряд:
>
> s2 := a[1:1+4] → a[1:5] → [20 30 40 50]
>
> Обобщённая формула
>
> s := a[i:j]
>
> cap(s) == len(a) - i
>
> s2 := s[:cap(s)]
>
> Тогда:
>
> s2 == a[i : i+cap(s)] == a[i : len(a)]
>
> ---

### С помощью make

Позволяет задать размер и ёмкость:
```go
s := make([]int, 5) // длина = 5, ёмкость = 5, значения по умолчанию = 0
fmt.Println(s)        // [0 0 0 0 0]
fmt.Println(len(s))   // 5
fmt.Println(cap(s))   // 5
```

Можно также задать явно ёмкость:

```go
s := make([]int, 2, 10) // длина = 2, ёмкость = 10
fmt.Println(s)        // [0 0]
fmt.Println(len(s))   // 2
fmt.Println(cap(s))   // 10
```

Это полезно, если предполагается много append() — чтобы избежать частого выделения памяти.

### Нулевой срез (nil)

```go
var s []int
fmt.Println(s == nil) // true
fmt.Println(len(s))   // 0
fmt.Println(cap(s))   // 0
```

Это "нулевой" срез — он не указывает ни на какой массив. Часто используется как "пустое значение по умолчанию".

### Пустой срез ([]T{})

```go
s := []int{}
fmt.Println(s == nil) // false
fmt.Println(len(s))   // 0
```

Пустой срез указывает на уже выделенный (но пустой) массив. Полезен, когда важно, чтобы s != nil.

## Длина и ёмкость срезов

- Длина (len) — это количество доступных элементов в срезе.
- Ёмкость (cap) — это количество элементов, которое можно разместить в срезе до перераспределения памяти.

Они задаются в момент создания среза и определяют, как работает append() и другие операции.

### Примеры с len и cap

```go
arr := [5]int{10, 20, 30, 40, 50}
s := arr[1:4] // → [20 30 40]
fmt.Println(len(s)) // 3 → элементы 1,2,3
fmt.Println(cap(s)) // 4 → от элемента 1 до конца arr
```

```go
s = s[:2] // теперь только [20 30]
fmt.Println(len(s)) // 2
fmt.Println(cap(s)) // по-прежнему 4
```

> len(s) ограничивает видимую длину, но cap(s) остаётся прежней — это важно при работе с append().

### Управление длиной и ёмкостью через make

```go
s := make([]int, 2, 5)
fmt.Println(len(s)) // 2
fmt.Println(cap(s)) // 5
```

Можно расширить len, пока не превышена cap:
```go
s = s[:4] // теперь длина 4
```

Но нельзя выйти за пределы cap напрямую:
```go
s = s[:6] // panic: runtime error: slice bounds out of range
```

### Рост cap при append()
Если добавить элементы через append, и они не превышают cap, то данные помещаются в ту же область памяти:
```go
s := make([]int, 2, 5)
s = append(s, 1, 2) // cap=5 ещё не исчерпан
```

Если append выходит за cap, Go выделяет новый массив (срез отсоединяется от старого массива):
```go
s := []int{1, 2, 3}
s2 := append(s, 4, 5, 6, 7, 8) // старый cap исчерпан
```

**Новая ёмкость обычно увеличивается в 2 раза, но это зависит от стратегии рантайма Go.**

### Пример: отсоединение от исходного массива

```go
a := []int{1, 2, 3}
b := append(a, 4, 5, 6, 7, 8) // новая память

a[0] = 999
fmt.Println(b[0]) // всё равно 1 — потому что b не связан с a
```
### Резервирование памяти

Чтобы избежать лишних аллокаций:
```go
s := make([]int, 0, 1000) // изначально пустой, но с большой ёмкостью
for i := 0; i < 1000; i++ {
    s = append(s, i)
}
```

## Копирование и удаление элементов в срезе

Работа с срезами часто требует:

- создать независимую копию, чтобы избежать побочных эффектов;
- удалить элемент по индексу или диапазон.

### Копирование

**copy(dst, src)**
```go
copy(dstSlice, srcSlice []T) int
```

- Копирует элементы из src в dst.
- Возвращает фактическое число скопированных элементов.

> Если быть более точным, то функция copy выполняет копирование элементов из src НО! только в те ячейки dst, в которые уже что-то записано.
> То есть, copy() в Go — это не "копирование с расширением", а "перезапись уже существующих ячеек" в dst.
>
> **Что делает copy(dst, src)?**
>
> - Смотрит, сколько доступно по len(dst) — это зона разрешённой записи.
> - Перебирает элементы src.
> - Перезаписывает элементы в dst[0], dst[1], и так далее — но только в пределах len(dst).
>
> **Что copy() не делает:**
>
> - ❌ Не расширяет dst.
> - ❌ Не добавляет элементы "в конец".
> - ❌ Не создаёт dst, если он nil или len == 0.

**append()**

> Не смотря на то, что эта функция в основном используется для добавления элемента в срез, при ее помощи можно скопировать один срез в другой.

Пример слияния срезов:

```go
a := []int{1, 2, 3}
b := []int{4, 5, 6}
a = append(a, b...)
fmt.Println(a) // [1 2 3 4 5 6]```
```
Конструкция ..., в частности в нашем примере b..., называется "распаковка слайса" или "variadic slice expansion".
Форма b... говорит append:  «Передай каждый элемент b как отдельный аргумент».

> Так будет ошибка:
```go
a := []int{1, 2}
b := []int{3, 4}

// ❌ ошибка компиляции:
res := append(a, b) // нельзя — b это []int, а не int, int
```

### Удаление элемента по индексу

```go
s := []int{1, 2, 3, 4, 5}
i := 2 // индекс для удаления
s = append(s[:i], s[i+1:]...)
fmt.Println(s) // [1 2 4 5]
```

- s[:i] — всё до i-элемента (исключая его),
- s[i+1:] — всё после i-элемента,
- append объединяет оба фрагмента.

> Что конкрентно делает append(s[:i], s[i+1:]...)
>
> - На время выполнения функции append формируются два подсреза s[:i] и s[i+1:].
>
> ```bash
> s[:i]     → [1 2] // до удаляемого
> s[i+1:]   → [4 5] // после удаляемого
> ```
>
> append(...) склеивает их: [1 2] + [4 5] → [1 2 4 5].
>
> И теперь самое главное:
>
> - `s[:i]` указывает на тот же массив, как и изначальный `s`
> - У него len = 2, cap = 5 — значит append может дописать в тот же массив
> - Он копирует 4 в `s[2]` (в ячейку где хранилось значение 3) и 5 в `s[3]` (в ячейку где хранилось значение 4)
>
> Что с s[4] в оригинальном массиве? Там было и остается 5, и его никто не трогает.
> Поэтому:
>
> ```go
> // массив в памяти остаётся:
> [1 2 4 5 5]
> // ^ ^ ^ ^ ^
> // 0 1 2 3 4
>
> // но срез s теперь длиной 4
> s = s[:4] → [1 2 4 5]
> ```
>
> Доказательство через отладку
>
> ```go
> s := []int{1, 2, 3, 4, 5}
> i := 2
> s2 := append(s[:i], s[i+1:]...)
>
> fmt.Println(s2)     // [1 2 4 5]
> fmt.Println(s)      // [1 2 4 5 5]
> ```
>
> Вывод:
>
> - [1 2 4 5 5] — это содержимое исходного массива, где 3 перезаписанно 4, а четыре перезаписано значением 5, но хвостовая 5 осталась нетронута.
> - Новый срез s2 указывает на первые 4 элемента: [1 2 4 5]
> - Никто не "вписал пятёрку" дважды — она уже там была как часть исходного массива