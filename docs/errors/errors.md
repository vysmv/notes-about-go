# Ошибки в Go

**В этом разделе будет описана работа с ошибками на этапе выполнения програмы.**

## Введение в концепцию ошибок в Go

### Почему в Go ошибки — это значение, а не исключение

Go не использует классическую систему исключений (try/catch/finally), как, например, Java, Python или C#. Вместо этого ошибка — это обычное возвращаемое значение, которое явно проверяется вызывающим кодом.

Причины такого выбора:

- Явность: if err != nil видно сразу — нет скрытого поведения.
- Простота управления потоком: обработка ошибок — часть основного алгоритма.
- Предсказуемость: программа не "прыгает" через стек вызовов при исключении.
- Безопасность в проде: избегается глобальная паника по пустякам.

Go-девелоперы не пишут try/catch, они возвращают ошибку и проверяют её вручную.

### Интерфейс error — центральное понятие

В стандартной библиотеке Go определён интерфейс:
```go
type error interface {
    Error() string
}
```

> Интерфейс error определён не в пакете errors, а в пакете builtin — то есть в самом ядре языка, наряду с int, string, bool, append и т.д.
> 
> А что тогда в пакете errors?
>
> Пакет errors предоставляет инструменты для создания значений, реализующих интерфейс error. Он не определяет интерфейс, а лишь возвращает его реализации.

Любой тип, у которого есть метод Error() string, автоматически реализует интерфейс error.
Пример:
```go
type MyError struct {}

func (e MyError) Error() string {
    return "что-то пошло не так"
}
```
Теперь MyError можно вернуть как error.

### Пример функции с ошибкой

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}
```

Использование:
```go
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Ошибка:", err)
    return
}
fmt.Println("Результат:", result)
```

Ключевая особенность:

- Возвращается два значения: полезный результат и ошибка.
- Ошибки всегда обрабатываются явно.

## Базовая работа с ошибками

### Создание ошибок

Go предлагает два основных способа создания ошибок:

- **errors.New — простая ошибка с сообщением**

```go
import "errors"

err := errors.New("что-то пошло не так")
```
Это создаёт объект, реализующий интерфейс error. Сообщение задаётся как строка.

- **fmt.Errorf — ошибка с форматированием (без обёртки пока)**

```go
import "fmt"

name := "Иван"
err := fmt.Errorf("пользователь %s не найден", name)
```
> Что возвращает errors.New?
>
> Функция errors.New из пакета errors на самом деле возвращает значение следующего конкретного типа (внутри стандартной библиотеки):
> ```go
> type errorString struct {
>     s string
> }
>
> func (e *errorString) Error() string {
>     return e.s
> }
> ```
> И сам errors.New реализован так:
> ```go
> func New(text string) error {
>     return &errorString{text}
> }
> ```

### Возврат ошибок из функций

Типичный шаблон функции, которая может завершиться с ошибкой:
```go
func doSomething() (string, error) {
    if что-то_не_так {
        return "", errors.New("описание ошибки")
    }
    return "успех", nil
}
```
Если всё в порядке — возвращается результат и nil вместо ошибки.

## Стандартный пакет errors

### errors.Is(err, target) — сравнение ошибок

```go
var ErrNotFound = errors.New("не найдено")

func getUser(id int) error {
    return fmt.Errorf("getUser: %w", ErrNotFound)
}

err := getUser(42)
if errors.Is(err, ErrNotFound) {
    fmt.Println("Пользователь не найден")
}
```

Работает даже если ошибка обёрнута через %w.

Важно:

- Is() работает через Unwrap(), см. ниже.
- То есть он распаковывает ошибки и сравнивает вложенные.

### errors.As(err, &target) — извлечение конкретного типа

Позволяет проверить: ошибка относится к определённому типу, и если да, то получить доступ к её полям.

```go
type MyError struct {
    Code int
}

func (e MyError) Error() string {
    return fmt.Sprintf("код ошибки: %d", e.Code)
}

func do() error {
    return fmt.Errorf("ошибка: %w", MyError{Code: 123})
}

err := do()

var myErr MyError
if errors.As(err, &myErr) {
    fmt.Println("Это MyError с кодом:", myErr.Code)
}
```

### errors.Unwrap(err) — извлечь вложенную ошибку

Если ошибка обёрнута (wrapped), Unwrap достаёт её.
```go
baseErr := errors.New("базовая")
wrapped := fmt.Errorf("высокоуровневая: %w", baseErr)

unwrapped := errors.Unwrap(wrapped)
fmt.Println(unwrapped) // "базовая"
```
Цепочка:

Если обёрнуто несколько раз, errors.Is и errors.As пройдут по всей цепочке.
А Unwrap — возвращает только первый уровень.

### Отличие %w от %v в fmt.Errorf

- %w — это wrap: оборачивает ошибку с сохранением оригинала
- %v — просто вставляет текст ошибки, не сохраняет связь
```go
err1 := errors.New("низкоуровневая")
err2 := fmt.Errorf("контекст: %w", err1) // ok
err3 := fmt.Errorf("контекст: %v", err1) // обёртки нет
```

```go
errors.Is(err2, err1) → true

errors.Is(err3, err1) → false
```

### Когда использовать Is vs As

| Задача                                 | Использовать |
|----------------------------------------|--------------|
| Проверить, была ли ошибка `ErrX`       | `errors.Is`  |
| Проверить, ошибка ли это тип `MyError` | `errors.As`  |

### Что делает fmt.Errorf("...", %w) внутри?

По сути, создаёт тип, реализующий:
```go
type wrappedError struct {
    msg string
    err error
}

func (w wrappedError) Error() string  { return w.msg }
func (w wrappedError) Unwrap() error  { return w.err }
```
Это позволяет извлекать вложенную ошибку через Unwrap(), и Is / As работают по цепочке.

## Оборачивание ошибок

### Зачем оборачивать ошибки?

Когда ошибка проходит через несколько уровней вызовов, важно:

- не терять оригинальную причину;
- добавлять контекст — где именно ошибка произошла;
- при этом давать возможность программе узнать тип или значение ошибки.

```go
func openConfig(path string) error {
    b, err := os.ReadFile(path)
    if err != nil {
        return fmt.Errorf("не удалось открыть конфиг %q: %w", path, err)
    }
    _ = b
    return nil
}
```
Здесь ошибка от os.ReadFile оборачивается с пояснением: где и почему она возникла.
И при этом %w сохраняет оригинальную ошибку.

### Как правильно оборачивать — %w в fmt.Errorf

```go
return fmt.Errorf("ошибка в операции: %w", err)
```

- %w — означает "wrap this error"
- Работает только один раз в строке (fmt.Errorf поддерживает максимум одно %w)

> %w — это единственный способ обернуть ошибку в Go stdlib, чтобы errors.Is и errors.As продолжали работать.

### Неправильный wrap через %v — потеря семантики

```go
return fmt.Errorf("ошибка: %v", err) // ❌ не обёрнута!
```

Здесь err просто вставлен в строку, но не обёрнут, и errors.Is/As уже не сработают.

### Идиома: добавляй контекст, когда не ты создал ошибку

- Если ошибка получена от вызова ниже — добавь контекст
- Если ты создаёшь ошибку "с нуля" — просто errors.New или fmt.Errorf без %w

```go
func read() error {
    b, err := os.ReadFile("file.txt")
    if err != nil {
        return fmt.Errorf("read failed: %w", err)
    }
    _ = b
    return nil
}
```